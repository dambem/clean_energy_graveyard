import { Synced } from "../Synced.svelte";
import { dataAttr } from "../utils/attribute";
import { addEventListener } from "../utils/event";
import { extract } from "../utils/extract";
import { createDataIds, createIds } from "../utils/identifiers";
import { isHtmlElement } from "../utils/is";
import { deepMerge } from "../utils/merge";
import { autoUpdate, computePosition, flip, offset, shift, } from "@floating-ui/dom";
import { useEventListener } from "runed";
const dataIds = createDataIds("popover", ["trigger", "content"]);
export class Popover {
    #ids = createIds(dataIds);
    /* Props */
    #props;
    forceVisible = $derived(extract(this.#props.forceVisible, false));
    computePositionOptions = $derived(extract(this.#props.computePositionOptions, {}));
    /* State */
    #open;
    constructor(props = {}) {
        this.#open = new Synced({
            value: props.open,
            onChange: props.onOpenChange,
            defaultValue: false,
        });
        this.#props = props;
    }
    get open() {
        return this.#open.current;
    }
    set open(value) {
        this.#open.current = value;
    }
    get #sharedProps() {
        return {
            onfocusout: async () => {
                await new Promise((r) => setTimeout(r));
                const contentEl = document.getElementById(this.#ids.content);
                const triggerEl = document.getElementById(this.#ids.trigger);
                if (contentEl?.contains(document.activeElement) ||
                    triggerEl?.contains(document.activeElement)) {
                    return;
                }
                this.open = false;
            },
        };
    }
    /** The trigger that toggles the value. */
    get trigger() {
        return {
            [dataIds.trigger]: "",
            id: this.#ids.trigger,
            popovertarget: this.#ids.content,
            onclick: (e) => {
                e.preventDefault();
                this.open = !this.open;
            },
            ...this.#sharedProps,
        };
    }
    get content() {
        // Show and hide popover based on open state
        $effect(() => {
            const el = document.getElementById(this.#ids.content);
            if (!isHtmlElement(el)) {
                return;
            }
            if (this.open || this.forceVisible) {
                // Check if there's a parent popover. If so, only open if the parent's open.
                // This is to guarantee correct layering.
                const parent = isHtmlElement(el.parentNode)
                    ? el.parentNode.closest(`[${dataIds.content}]`)
                    : undefined;
                if (!isHtmlElement(parent)) {
                    el.showPopover();
                    return;
                }
                if (parent.dataset.open !== undefined)
                    el.showPopover();
                return addEventListener(parent, "toggle", async (e) => {
                    await new Promise((r) => setTimeout(r));
                    const isOpen = e.newState === "open";
                    if (isOpen) {
                        el.showPopover();
                    }
                    else {
                        el.hidePopover();
                    }
                });
            }
            else {
                el.hidePopover();
            }
        });
        // Floating UI
        const compute = () => {
            const contentEl = document.getElementById(this.#ids.content);
            const triggerEl = document.getElementById(this.#ids.trigger);
            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl)) {
                return;
            }
            const baseOptions = {
                middleware: [shift(), flip(), offset({ mainAxis: 8 })],
            };
            computePosition(triggerEl, contentEl, deepMerge(baseOptions, this.computePositionOptions)).then(({ x, y, placement }) => {
                const transformOriginMap = {
                    top: "bottom center",
                    "top-start": "bottom left",
                    "top-end": "bottom right",
                    bottom: "top center",
                    "bottom-start": "top left",
                    "bottom-end": "top right",
                    left: "center center",
                    "left-start": "top left",
                    "left-end": "bottom left",
                    right: "center center",
                    "right-start": "top right",
                    "right-end": "bottom right",
                };
                Object.assign(contentEl.style, {
                    left: `${x}px`,
                    top: `${y}px`,
                });
                contentEl.style.transformOrigin = transformOriginMap[placement];
                contentEl.dataset.side = placement;
            });
        };
        $effect(() => {
            const contentEl = document.getElementById(this.#ids.content);
            const triggerEl = document.getElementById(this.#ids.trigger);
            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl)) {
                return;
            }
            return autoUpdate(triggerEl, contentEl, compute);
        });
        useEventListener(() => document, "keydown", (e) => {
            const el = document.getElementById(this.#ids.content);
            if (e.key !== "Escape" || !this.open || !isHtmlElement(el))
                return;
            e.preventDefault();
            const openPopovers = [...el.querySelectorAll("[popover]")].filter((child) => {
                if (!isHtmlElement(child))
                    return false;
                // If child is a Melt popover, check if it's open
                if (child.matches(`[${dataIds.content}]`))
                    return child.dataset.open !== undefined;
                return child.matches(":popover-open");
            });
            if (openPopovers.length)
                return;
            // Set timeout to give time to all event listeners to run
            setTimeout(() => (this.open = false));
        });
        useEventListener(() => document, "click", (e) => {
            const contentEl = document.getElementById(this.#ids.content);
            const triggerEl = document.getElementById(this.#ids.trigger);
            if (this.open &&
                !contentEl?.contains(e.target) &&
                !triggerEl?.contains(e.target)) {
                this.open = false;
            }
        });
        return {
            [dataIds.content]: "",
            id: this.#ids.content,
            popover: "manual",
            ontoggle: (e) => {
                const newOpen = e.newState === "open";
                if (this.open !== newOpen && newOpen === false) {
                    this.open = newOpen;
                }
            },
            tabindex: -1,
            inert: !this.open,
            "data-open": dataAttr(this.open),
            ...this.#sharedProps,
        };
    }
}
